{"ast":null,"code":"//! stable.js 0.1.8, https://github.com/Two-Screen/stable\n//! © 2018 Angry Bytes and contributors. MIT licensed.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.stable = factory();\n})(this, function () {\n  'use strict'; // A stable array sort, because `Array#sort()` is not guaranteed stable.\n  // This is an implementation of merge sort, without recursion.\n\n  var stable = function (arr, comp) {\n    return exec(arr.slice(), comp);\n  };\n\n  stable.inplace = function (arr, comp) {\n    var result = exec(arr, comp); // This simply copies back if the result isn't in the original array,\n    // which happens on an odd number of passes.\n\n    if (result !== arr) {\n      pass(result, null, arr.length, arr);\n    }\n\n    return arr;\n  }; // Execute the sort using the input array and a second buffer as work space.\n  // Returns one of those two, containing the final result.\n\n\n  function exec(arr, comp) {\n    if (typeof comp !== 'function') {\n      comp = function (a, b) {\n        return String(a).localeCompare(b);\n      };\n    } // Short-circuit when there's nothing to sort.\n\n\n    var len = arr.length;\n\n    if (len <= 1) {\n      return arr;\n    } // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.\n    // Chunks are the size of the left or right hand in merge sort.\n    // Stop when the left-hand covers all of the array.\n\n\n    var buffer = new Array(len);\n\n    for (var chk = 1; chk < len; chk *= 2) {\n      pass(arr, comp, chk, buffer);\n      var tmp = arr;\n      arr = buffer;\n      buffer = tmp;\n    }\n\n    return arr;\n  } // Run a single pass with the given chunk size.\n\n\n  var pass = function (arr, comp, chk, result) {\n    var len = arr.length;\n    var i = 0; // Step size / double chunk size.\n\n    var dbl = chk * 2; // Bounds of the left and right chunks.\n\n    var l, r, e; // Iterators over the left and right chunk.\n\n    var li, ri; // Iterate over pairs of chunks.\n\n    for (l = 0; l < len; l += dbl) {\n      r = l + chk;\n      e = r + chk;\n      if (r > len) r = len;\n      if (e > len) e = len; // Iterate both chunks in parallel.\n\n      li = l;\n      ri = r;\n\n      while (true) {\n        // Compare the chunks.\n        if (li < r && ri < e) {\n          // This works for a regular `sort()` compatible comparator,\n          // but also for a simple comparator like: `a > b`\n          if (comp(arr[li], arr[ri]) <= 0) {\n            result[i++] = arr[li++];\n          } else {\n            result[i++] = arr[ri++];\n          }\n        } // Nothing to compare, just flush what's left.\n        else if (li < r) {\n            result[i++] = arr[li++];\n          } else if (ri < e) {\n            result[i++] = arr[ri++];\n          } // Both iterators are at the chunk ends.\n          else {\n              break;\n            }\n      }\n    }\n  };\n\n  return stable;\n});","map":{"version":3,"sources":["/home/ranju/location/meDossier/frontend/node_modules/stable/stable.js"],"names":["global","factory","exports","module","define","amd","stable","arr","comp","exec","slice","inplace","result","pass","length","a","b","String","localeCompare","len","buffer","Array","chk","tmp","i","dbl","l","r","e","li","ri"],"mappings":"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","sourcesContent":["//! stable.js 0.1.8, https://github.com/Two-Screen/stable\n//! © 2018 Angry Bytes and contributors. MIT licensed.\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.stable = factory());\n}(this, (function () { 'use strict';\n\n  // A stable array sort, because `Array#sort()` is not guaranteed stable.\n  // This is an implementation of merge sort, without recursion.\n\n  var stable = function (arr, comp) {\n    return exec(arr.slice(), comp)\n  };\n\n  stable.inplace = function (arr, comp) {\n    var result = exec(arr, comp);\n\n    // This simply copies back if the result isn't in the original array,\n    // which happens on an odd number of passes.\n    if (result !== arr) {\n      pass(result, null, arr.length, arr);\n    }\n\n    return arr\n  };\n\n  // Execute the sort using the input array and a second buffer as work space.\n  // Returns one of those two, containing the final result.\n  function exec(arr, comp) {\n    if (typeof(comp) !== 'function') {\n      comp = function (a, b) {\n        return String(a).localeCompare(b)\n      };\n    }\n\n    // Short-circuit when there's nothing to sort.\n    var len = arr.length;\n    if (len <= 1) {\n      return arr\n    }\n\n    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.\n    // Chunks are the size of the left or right hand in merge sort.\n    // Stop when the left-hand covers all of the array.\n    var buffer = new Array(len);\n    for (var chk = 1; chk < len; chk *= 2) {\n      pass(arr, comp, chk, buffer);\n\n      var tmp = arr;\n      arr = buffer;\n      buffer = tmp;\n    }\n\n    return arr\n  }\n\n  // Run a single pass with the given chunk size.\n  var pass = function (arr, comp, chk, result) {\n    var len = arr.length;\n    var i = 0;\n    // Step size / double chunk size.\n    var dbl = chk * 2;\n    // Bounds of the left and right chunks.\n    var l, r, e;\n    // Iterators over the left and right chunk.\n    var li, ri;\n\n    // Iterate over pairs of chunks.\n    for (l = 0; l < len; l += dbl) {\n      r = l + chk;\n      e = r + chk;\n      if (r > len) r = len;\n      if (e > len) e = len;\n\n      // Iterate both chunks in parallel.\n      li = l;\n      ri = r;\n      while (true) {\n        // Compare the chunks.\n        if (li < r && ri < e) {\n          // This works for a regular `sort()` compatible comparator,\n          // but also for a simple comparator like: `a > b`\n          if (comp(arr[li], arr[ri]) <= 0) {\n            result[i++] = arr[li++];\n          }\n          else {\n            result[i++] = arr[ri++];\n          }\n        }\n        // Nothing to compare, just flush what's left.\n        else if (li < r) {\n          result[i++] = arr[li++];\n        }\n        else if (ri < e) {\n          result[i++] = arr[ri++];\n        }\n        // Both iterators are at the chunk ends.\n        else {\n          break\n        }\n      }\n    }\n  };\n\n  return stable;\n\n})));\n"]},"metadata":{},"sourceType":"script"}