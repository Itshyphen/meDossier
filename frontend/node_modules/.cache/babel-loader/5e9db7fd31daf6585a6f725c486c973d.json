{"ast":null,"code":"import getLength from './_getLength.js';\nimport isFunction from './isFunction.js';\nimport allKeys from './allKeys.js'; // Since the regular `Object.prototype.toString` type tests don't work for\n// some types in IE 11, we use a fingerprinting heuristic instead, based\n// on the methods. It's not great, but it's the best we got.\n// The fingerprint method lists are defined below.\n\nexport function ie11fingerprint(methods) {\n  var length = getLength(methods);\n  return function (obj) {\n    if (obj == null) return false; // `Map`, `WeakMap` and `Set` have no enumerable keys.\n\n    var keys = allKeys(obj);\n    if (getLength(keys)) return false;\n\n    for (var i = 0; i < length; i++) {\n      if (!isFunction(obj[methods[i]])) return false;\n    } // If we are testing against `WeakMap`, we need to ensure that\n    // `obj` doesn't have a `forEach` method in order to distinguish\n    // it from a regular `Map`.\n\n\n    return methods !== weakMapMethods || !isFunction(obj[forEachName]);\n  };\n} // In the interest of compact minification, we write\n// each string in the fingerprints only once.\n\nvar forEachName = 'forEach',\n    hasName = 'has',\n    commonInit = ['clear', 'delete'],\n    mapTail = ['get', hasName, 'set']; // `Map`, `WeakMap` and `Set` each have slightly different\n// combinations of the above sublists.\n\nexport var mapMethods = commonInit.concat(forEachName, mapTail),\n    weakMapMethods = commonInit.concat(mapTail),\n    setMethods = ['add'].concat(commonInit, forEachName, hasName);","map":{"version":3,"sources":["/home/ranju/location/meDossier/node_modules/underscore/modules/_methodFingerprint.js"],"names":["getLength","isFunction","allKeys","ie11fingerprint","methods","length","obj","keys","i","weakMapMethods","forEachName","hasName","commonInit","mapTail","mapMethods","concat","setMethods"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,iBAAtB;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,OAAOC,OAAP,MAAoB,cAApB,C,CAEA;AACA;AACA;AACA;;AACA,OAAO,SAASC,eAAT,CAAyBC,OAAzB,EAAkC;AACvC,MAAIC,MAAM,GAAGL,SAAS,CAACI,OAAD,CAAtB;AACA,SAAO,UAASE,GAAT,EAAc;AACnB,QAAIA,GAAG,IAAI,IAAX,EAAiB,OAAO,KAAP,CADE,CAEnB;;AACA,QAAIC,IAAI,GAAGL,OAAO,CAACI,GAAD,CAAlB;AACA,QAAIN,SAAS,CAACO,IAAD,CAAb,EAAqB,OAAO,KAAP;;AACrB,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAApB,EAA4BG,CAAC,EAA7B,EAAiC;AAC/B,UAAI,CAACP,UAAU,CAACK,GAAG,CAACF,OAAO,CAACI,CAAD,CAAR,CAAJ,CAAf,EAAkC,OAAO,KAAP;AACnC,KAPkB,CAQnB;AACA;AACA;;;AACA,WAAOJ,OAAO,KAAKK,cAAZ,IAA8B,CAACR,UAAU,CAACK,GAAG,CAACI,WAAD,CAAJ,CAAhD;AACD,GAZD;AAaD,C,CAED;AACA;;AACA,IAAIA,WAAW,GAAG,SAAlB;AAAA,IACIC,OAAO,GAAG,KADd;AAAA,IAEIC,UAAU,GAAG,CAAC,OAAD,EAAU,QAAV,CAFjB;AAAA,IAGIC,OAAO,GAAG,CAAC,KAAD,EAAQF,OAAR,EAAiB,KAAjB,CAHd,C,CAKA;AACA;;AACA,OAAO,IAAIG,UAAU,GAAGF,UAAU,CAACG,MAAX,CAAkBL,WAAlB,EAA+BG,OAA/B,CAAjB;AAAA,IACHJ,cAAc,GAAGG,UAAU,CAACG,MAAX,CAAkBF,OAAlB,CADd;AAAA,IAEHG,UAAU,GAAG,CAAC,KAAD,EAAQD,MAAR,CAAeH,UAAf,EAA2BF,WAA3B,EAAwCC,OAAxC,CAFV","sourcesContent":["import getLength from './_getLength.js';\nimport isFunction from './isFunction.js';\nimport allKeys from './allKeys.js';\n\n// Since the regular `Object.prototype.toString` type tests don't work for\n// some types in IE 11, we use a fingerprinting heuristic instead, based\n// on the methods. It's not great, but it's the best we got.\n// The fingerprint method lists are defined below.\nexport function ie11fingerprint(methods) {\n  var length = getLength(methods);\n  return function(obj) {\n    if (obj == null) return false;\n    // `Map`, `WeakMap` and `Set` have no enumerable keys.\n    var keys = allKeys(obj);\n    if (getLength(keys)) return false;\n    for (var i = 0; i < length; i++) {\n      if (!isFunction(obj[methods[i]])) return false;\n    }\n    // If we are testing against `WeakMap`, we need to ensure that\n    // `obj` doesn't have a `forEach` method in order to distinguish\n    // it from a regular `Map`.\n    return methods !== weakMapMethods || !isFunction(obj[forEachName]);\n  };\n}\n\n// In the interest of compact minification, we write\n// each string in the fingerprints only once.\nvar forEachName = 'forEach',\n    hasName = 'has',\n    commonInit = ['clear', 'delete'],\n    mapTail = ['get', hasName, 'set'];\n\n// `Map`, `WeakMap` and `Set` each have slightly different\n// combinations of the above sublists.\nexport var mapMethods = commonInit.concat(forEachName, mapTail),\n    weakMapMethods = commonInit.concat(mapTail),\n    setMethods = ['add'].concat(commonInit, forEachName, hasName);\n"]},"metadata":{},"sourceType":"module"}