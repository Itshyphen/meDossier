{"ast":null,"code":"const BufferList = require('bl/BufferList');\n\nconst Reader = require('it-reader');\n\nmodule.exports = function LteReader(source) {\n  const reader = Reader(source);\n  let overflow;\n  const lteReader = {\n    [Symbol.asyncIterator]: () => lteReader,\n\n    async next(bytes) {\n      if (overflow) {\n        let value;\n\n        if (bytes == null || overflow.length === bytes) {\n          value = overflow;\n          overflow = null;\n        } else if (overflow.length > bytes) {\n          value = overflow.shallowSlice(0, bytes);\n          overflow = overflow.shallowSlice(bytes);\n        } else if (overflow.length < bytes) {\n          const {\n            value: nextValue,\n            done\n          } = await reader.next(bytes - overflow.length);\n\n          if (done) {\n            throw Object.assign(new Error(`stream ended before ${bytes - overflow.length} bytes became available`), {\n              code: 'ERR_UNDER_READ'\n            });\n          }\n\n          value = new BufferList([overflow, nextValue]);\n          overflow = null;\n        }\n\n        return {\n          value\n        };\n      }\n\n      return reader.next(bytes);\n    },\n\n    async nextLte(bytes) {\n      let {\n        done,\n        value\n      } = await lteReader.next();\n      if (done) return {\n        done\n      };\n      if (value.length <= bytes) return {\n        value\n      };\n      value = BufferList.isBufferList(value) ? value : new BufferList(value);\n\n      if (overflow) {\n        overflow.append(value.shallowSlice(bytes));\n      } else {\n        overflow = value.shallowSlice(bytes);\n      }\n\n      return {\n        value: value.shallowSlice(0, bytes)\n      };\n    },\n\n    return() {\n      return reader.return();\n    }\n\n  };\n  return lteReader;\n};","map":{"version":3,"sources":["/home/ranju/location/meDossier/frontend/node_modules/it-tar/lte-reader.js"],"names":["BufferList","require","Reader","module","exports","LteReader","source","reader","overflow","lteReader","Symbol","asyncIterator","next","bytes","value","length","shallowSlice","nextValue","done","Object","assign","Error","code","nextLte","isBufferList","append","return"],"mappings":"AAAA,MAAMA,UAAU,GAAGC,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAAtB;;AAEAE,MAAM,CAACC,OAAP,GAAiB,SAASC,SAAT,CAAoBC,MAApB,EAA4B;AAC3C,QAAMC,MAAM,GAAGL,MAAM,CAACI,MAAD,CAArB;AACA,MAAIE,QAAJ;AACA,QAAMC,SAAS,GAAG;AAChB,KAACC,MAAM,CAACC,aAAR,GAAwB,MAAMF,SADd;;AAEhB,UAAMG,IAAN,CAAYC,KAAZ,EAAmB;AACjB,UAAIL,QAAJ,EAAc;AACZ,YAAIM,KAAJ;;AACA,YAAID,KAAK,IAAI,IAAT,IAAiBL,QAAQ,CAACO,MAAT,KAAoBF,KAAzC,EAAgD;AAC9CC,UAAAA,KAAK,GAAGN,QAAR;AACAA,UAAAA,QAAQ,GAAG,IAAX;AACD,SAHD,MAGO,IAAIA,QAAQ,CAACO,MAAT,GAAkBF,KAAtB,EAA6B;AAClCC,UAAAA,KAAK,GAAGN,QAAQ,CAACQ,YAAT,CAAsB,CAAtB,EAAyBH,KAAzB,CAAR;AACAL,UAAAA,QAAQ,GAAGA,QAAQ,CAACQ,YAAT,CAAsBH,KAAtB,CAAX;AACD,SAHM,MAGA,IAAIL,QAAQ,CAACO,MAAT,GAAkBF,KAAtB,EAA6B;AAClC,gBAAM;AAAEC,YAAAA,KAAK,EAAEG,SAAT;AAAoBC,YAAAA;AAApB,cAA6B,MAAMX,MAAM,CAACK,IAAP,CAAYC,KAAK,GAAGL,QAAQ,CAACO,MAA7B,CAAzC;;AACA,cAAIG,IAAJ,EAAU;AACR,kBAAMC,MAAM,CAACC,MAAP,CACJ,IAAIC,KAAJ,CAAW,uBAAsBR,KAAK,GAAGL,QAAQ,CAACO,MAAO,yBAAzD,CADI,EAEJ;AAAEO,cAAAA,IAAI,EAAE;AAAR,aAFI,CAAN;AAID;;AACDR,UAAAA,KAAK,GAAG,IAAId,UAAJ,CAAe,CAACQ,QAAD,EAAWS,SAAX,CAAf,CAAR;AACAT,UAAAA,QAAQ,GAAG,IAAX;AACD;;AACD,eAAO;AAAEM,UAAAA;AAAF,SAAP;AACD;;AACD,aAAOP,MAAM,CAACK,IAAP,CAAYC,KAAZ,CAAP;AACD,KAzBe;;AA0BhB,UAAMU,OAAN,CAAeV,KAAf,EAAsB;AACpB,UAAI;AAAEK,QAAAA,IAAF;AAAQJ,QAAAA;AAAR,UAAkB,MAAML,SAAS,CAACG,IAAV,EAA5B;AACA,UAAIM,IAAJ,EAAU,OAAO;AAAEA,QAAAA;AAAF,OAAP;AACV,UAAIJ,KAAK,CAACC,MAAN,IAAgBF,KAApB,EAA2B,OAAO;AAAEC,QAAAA;AAAF,OAAP;AAC3BA,MAAAA,KAAK,GAAGd,UAAU,CAACwB,YAAX,CAAwBV,KAAxB,IAAiCA,KAAjC,GAAyC,IAAId,UAAJ,CAAec,KAAf,CAAjD;;AACA,UAAIN,QAAJ,EAAc;AACZA,QAAAA,QAAQ,CAACiB,MAAT,CAAgBX,KAAK,CAACE,YAAN,CAAmBH,KAAnB,CAAhB;AACD,OAFD,MAEO;AACLL,QAAAA,QAAQ,GAAGM,KAAK,CAACE,YAAN,CAAmBH,KAAnB,CAAX;AACD;;AACD,aAAO;AAAEC,QAAAA,KAAK,EAAEA,KAAK,CAACE,YAAN,CAAmB,CAAnB,EAAsBH,KAAtB;AAAT,OAAP;AACD,KArCe;;AAsChBa,IAAAA,MAAM,GAAI;AACR,aAAOnB,MAAM,CAACmB,MAAP,EAAP;AACD;;AAxCe,GAAlB;AA0CA,SAAOjB,SAAP;AACD,CA9CD","sourcesContent":["const BufferList = require('bl/BufferList')\nconst Reader = require('it-reader')\n\nmodule.exports = function LteReader (source) {\n  const reader = Reader(source)\n  let overflow\n  const lteReader = {\n    [Symbol.asyncIterator]: () => lteReader,\n    async next (bytes) {\n      if (overflow) {\n        let value\n        if (bytes == null || overflow.length === bytes) {\n          value = overflow\n          overflow = null\n        } else if (overflow.length > bytes) {\n          value = overflow.shallowSlice(0, bytes)\n          overflow = overflow.shallowSlice(bytes)\n        } else if (overflow.length < bytes) {\n          const { value: nextValue, done } = await reader.next(bytes - overflow.length)\n          if (done) {\n            throw Object.assign(\n              new Error(`stream ended before ${bytes - overflow.length} bytes became available`),\n              { code: 'ERR_UNDER_READ' }\n            )\n          }\n          value = new BufferList([overflow, nextValue])\n          overflow = null\n        }\n        return { value }\n      }\n      return reader.next(bytes)\n    },\n    async nextLte (bytes) {\n      let { done, value } = await lteReader.next()\n      if (done) return { done }\n      if (value.length <= bytes) return { value }\n      value = BufferList.isBufferList(value) ? value : new BufferList(value)\n      if (overflow) {\n        overflow.append(value.shallowSlice(bytes))\n      } else {\n        overflow = value.shallowSlice(bytes)\n      }\n      return { value: value.shallowSlice(0, bytes) }\n    },\n    return () {\n      return reader.return()\n    }\n  }\n  return lteReader\n}\n"]},"metadata":{},"sourceType":"script"}